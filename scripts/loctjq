#!/usr/bin/env bash
set -euo pipefail

usage() {
  cat <<'EOF'
loctjq â€” run jq queries against the newest Loctree snapshot

USAGE:
  loctjq [--snapshot <path>] [<jq-args...>] <jq-filter>
  loctjq [--snapshot <path>] [<jq-args...>] -- <jq-filter>

EXAMPLES:
  # show snapshot metadata
  loctjq '.metadata'

  # who imports a file (incoming edges)
  loctjq --arg file 'src/components/ui/CheckboxFormGroup.tsx' \
    '[.edges[] | select(.to == $file and .label == "import") | .from] | unique | length'

  # where a symbol is exported (export_index)
  loctjq --arg sym 'CheckboxFormGroup' '.export_index[$sym]'

  # all dead exports (import_count == 0)
  loctjq '[.export_index | to_entries[] | select(.value.import_count == 0)] | length'

  # files with most outgoing imports (blast radius)
  loctjq '[.edges[] | .from] | group_by(.) | map({file: .[0], count: length}) | sort_by(-.count) | .[0:10]'

  # circular import candidates (A imports B, B imports A)
  loctjq '[.edges[] | {a: .from, b: .to}] as $all | $all[] | select(. as $e | $all | any(.a == $e.b and .b == $e.a)) | [.a, .b] | sort | unique'

NOTES:
  - Snapshot discovery: newest .loctree/*/snapshot.json (by mtime)
  - Requires: jq
  - Tip: pipe to 'less' or 'jq -C' for colored output
EOF
}

if ! command -v jq >/dev/null 2>&1; then
  echo "loctjq: jq not found. Install jq (e.g. brew install jq)." >&2
  exit 2
fi

snapshot=""

if [[ ${1:-} == "--help" || ${1:-} == "-h" || ${1:-} == "help" ]]; then
  usage
  exit 0
fi

if [[ ${1:-} == "--snapshot" ]]; then
  snapshot=${2:-}
  if [[ -z ${snapshot} ]]; then
    echo "loctjq: --snapshot requires a path" >&2
    exit 2
  fi
  shift 2
fi

if [[ -z ${snapshot} ]]; then
  snapshot=$(ls -1t .loctree/*/snapshot.json 2>/dev/null | head -1 || true)
fi

if [[ -z ${snapshot} || ! -f ${snapshot} ]]; then
  echo "loctjq: no snapshot found at .loctree/*/snapshot.json" >&2
  echo "Run: loct (or loct scan) to generate a snapshot." >&2
  exit 1
fi

if [[ $# -lt 1 ]]; then
  echo "loctjq: missing jq filter" >&2
  echo "Snapshot: ${snapshot}" >&2
  usage
  exit 2
fi

filter=""
jq_args=()

# Accept either:
#   loctjq [jq-args...] <filter>
# or:
#   loctjq [jq-args...] -- <filter>
if [[ " $* " == *" -- "* ]]; then
  # split on first --
  while [[ $# -gt 0 ]]; do
    if [[ $1 == "--" ]]; then
      shift
      break
    fi
    jq_args+=("$1")
    shift
  done

  if [[ $# -ne 1 ]]; then
    echo "loctjq: expected exactly one jq filter after '--'" >&2
    usage
    exit 2
  fi

  filter=$1
else
  if [[ $# -eq 1 ]]; then
    filter=$1
  else
    # Heuristic: treat last argument as filter, everything before as jq args.
    filter=${!#}
    jq_args+=("${@:1:$#-1}")
  fi
fi

jq "${jq_args[@]}" "${filter}" "$snapshot"
